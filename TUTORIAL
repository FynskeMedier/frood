<p><em>Authors</em>: <a href="jers@fynskemedier.dk">Jens Riisom Schultz</a>, <a href="jsf@fynskemedier.dk">Johannes Skov Frandsen</a></p>

<p><em>Since</em>: 2011-06-21</p>

<p>The Frood standardizes the VC in MVC for XOOPS.</p>

<h1>MVC</h1>

<p>For an extensive description of MVC in general, read <a href="http://en.wikipedia.org/wiki/Model-view-controller">this wiki article</a>.</p>

<h1>Notations</h1>

<p>The Frood works with two different notations. <code>CamelCased</code> (CC) and <code>lower_cased_with_underscores</code> (LOW).</p>

<p>The Frood contains static utility methods to convert back and forth between the two, should you need them:</p>

<ul>
<li><a href="Frood/Class/FroodUtil.html#convertPhpNameToHtmlName"><code>FroodUtil::convertPhpNameToHtmlName()</code></a> converts from CC to LOW.</li>
<li><a href="Frood/Class/FroodUtil.html#convertHtmlNameToPhpName"><code>FroodUtil::convertHtmlNameToPhpName()</code></a> converts from LOW to CC.</li>
</ul>

<p>Here are a few examples of equivalent strings of the two formats:</p>

<pre><code>CC      | c_c
URL     | u_r_l      &lt;-- Yuck!   :'(
Json    | json       &lt;-- Hooray! &lt;3
OhMyGod | oh_my_god
ImageId | image_id
</code></pre>

<p><em>Because of the ugliness of strings like <code>u_r_l</code> it is recommended to always type acronyms in CC with only the first letter as a capital.</em></p>

<h1>The autoloader</h1>

<p>Frood sets an autoloader up for you.</p>

<p>To ensure your classes are autoloaded you simply need to place your classes in the correct files and the correct locations.</p>

<h2>Class and file name conventions</h2>

<p>Classes always start with the module name.</p>

<p>Classes are defined in files with the same name as the class.</p>

<p>Part of the file name may be the path to the file (confusing... see the examples).</p>

<h3>Examples</h3>

<p><code>XoopsImageSomething</code> should be defined in one of:</p>

<ul>
<li><code>XoopsImageSomething.php</code></li>
<li><code>Xoops/ImageSomething.php</code></li>
<li><code>XoopsImage/Something.php</code></li>
<li><code>Xoops/Image/Something.php</code></li>
</ul>

<h2>Class file locations</h2>

<p>Frood will always autoload all classes in <code>class/</code>.</p>

<p>In addition it will also autoload the classes in the app class folder, depending on which app you are running, i.e. one of:</p>

<ul>
<li><code>public/class/</code></li>
<li><code>admin/class/</code></li>
<li><code>local/class/</code></li>
<li><code>cron/class/</code></li>
</ul>

<p>It will recursively scan all folders in the class folders, giving you the freedom to organize your classes as you see fit. That being said, the following <em>conventions</em> should be adhered to, for consistency:</p>

<ul>
<li>Model classes should be placed in <code>class/model/</code>.</li>
<li>Controller classes should be placed in <code>class/controllers/</code>.</li>
</ul>

<h2>Template file locations</h2>

<p>Templates are placed in <code>templates/[app]/[controller]/[action].tpl.html</code>, where <code>app</code>, <code>controller</code> and <code>action</code> are on LOW form.</p>

<p>Example: <code>LolBananaController::kebabAction()</code>, in the <code>public</code> app would be rendered with the following template:</p>

<pre><code>templates/public/lol/kebab.tpl.html
</code></pre>

<h1>Controllers and actions</h1>

<p>Controllers must extend <a href="Frood/Class/FroodController.html"><code>FroodController</code></a>. The class name must begin with the module name on CC form, and end with <code>Controller</code>. They should be placed in an apps <code>class/controllers</code> folder, to ensure that they only are accesible from a specific app.</p>

<p>Controllers should implement some actions. These must be public methods, taking one parameter of the class, <a href="Frood/Class/FroodParameters.html"><code>FroodParameters</code></a>.</p>

<p>Controller actions are invoked by http requesting a URI or by <a href="Frood/Class/FroodRemote.html"><code>FroodRemote</code></a></p>

<p>Example: <code>LolBananaController::kebabAction()</code>, in the <code>public</code> app would be invoked with the following URI:</p>

<pre><code>/modules/lol/public/banana/kebab
</code></pre>

<p>or</p>

<pre><code>/modules/lol/banana/kebab
</code></pre>

<p>because the public app is default.</p>

<p>The same action could be reached by <a href="Frood/Class/FroodRemote.html"><code>FroodRemote</code></a>, using this code:</p>

<pre><code>    &lt;?php
    $remote = new FroodRemote('lol');

    $output = $remote-&gt;dispatch('banana', 'kebab');
    ?&gt;
</code></pre>

<p>See the section called <code>FroodRemote</code> for more information.</p>

<h1>Action output</h1>

<p>By default actions are rendered in a Xoops context. This means that <code>admin</code> pages will get the menu and look like admin pages, and that <code>public</code> pages will be rendered in the theme.</p>

<p><a href="Frood/Class/FroodController.html"><code>FroodController</code></a> has three output modes, which can be changed in an action by calling any one of the following, anywhere in the action (or controller constructor):</p>

<pre><code>    &lt;?php
    // ...
    $this-&gt;doOutputXoops();  // Default
    $this-&gt;doOutputSmarty(); // Just smarty
    $this-&gt;doOutputJson();   // JSON formatted output - ignores any template
    // ...
    ?&gt;
</code></pre>

<h1>Action parameters</h1>

<p>All actions take an instance of <a href="Frood/Class/FroodParameters.html"><code>FroodParameters</code></a> as the first, and often only, parameter.</p>

<p>You should never access <code>$_GET</code>, <code>$_POST</code> and <code>$_FILES</code> directly. Instead you use the parameters instance, and call <code>getXxx()</code> methods on it:</p>

<pre><code>    &lt;?php
    // ...
    public function someAction(FroodParameters $params) {
        // Attempt to get the value of the get or post parameter, "id".
        // Will throw an exception if this parameter is not set!
        $id = $params-&gt;getId();

        // Same as above but will throw an exception
        // if a given value cannot be casted to integer.
        $id = $params-&gt;getId(FroodParameters::AS_INTEGER);

        // Same as above, but instead of an exception you get 42.
        $id = $params-&gt;getId(FroodParameters::AS_INTEGER, 42);
    }
    // ...
    ?&gt;
</code></pre>

<p>You can also test whether a given parameter is set, without having to catch an exception, by calling the <code>hasXxx()</code> functions:</p>

<pre><code>    &lt;?php
    // ...
    public function someAction(FroodParameters $params) {
        if ($params-&gt;hasBigSalmon()) {
            // This is invoked if a parameter called, "big_salmon" is given.
        }
        if ($params-&gt;hasHugeStork(FroodParameters::AS_STRING)) {
            // This is invoked if a parameter called, "huge_stork" is given,
            // and it can be typecast as a string.
        }
    }
    // ...
    ?&gt;
</code></pre>

<p>There are various <code>AS_</code>-constants you can use. Find them on [the documentation page for <a href="Frood/Class/FroodParameters.html"><code>FroodParameters</code></a>.</p>

<h2>File parameters</h2>

<p>Submitted files are accessed through the parameters instance, like other parameters, but instead of an integer, string or array, you get an instance of <a href="Frood/Class/FroodFileParameter.html"><code>FroodFileParameter</code></a>. See the documentation for the class, for a description of it's methods.</p>

<h1><code>FroodRemote</code></h1>

<p>The <a href="Frood/Class/FroodRemote.html"><code>FroodRemote</code></a> facilitates working with other modules Frood enabled modules, without the hassle of HTTP'ing yourself. As an added bonus, it will work directly with PHP when communicating with other local modules, eliminating the overhead of HTTP requests.</p>

<p>To call an action on a local module, simply instantiate a <a href="Frood/Class/FroodRemote.html"><code>FroodRemote</code></a> and call <a href="Frood/Class/FroodRemote.html#dispatch"><code>dispatch</code></a>:</p>

<pre><code>    &lt;?php
    $remote = new FroodRemote('lol');

    $output = $remote-&gt;dispatch('banana', 'kebab');

    // And with some parameters:
    $output = $remote-&gt;dispatch('banana', 'kebab', new FroodParameters(
        array(
            'id'         =&gt; 42,
            'some_thing' =&gt; 'Meget hest',
            'some_file'  =&gt; new FroodFileParameter(
                '/path/to/local/file'
            ),
        )
    ));

    ?&gt;
</code></pre>

<h1>The apps</h1>

<p>The Frood makes 4 distinctively different apps available for implementation. Every app is optional.</p>

<p>Generally, the apps can be accessed via http requests to URI's of the following format:</p>

<pre><code>/modules/[moduleName]/[app]/[controller]/[action]
</code></pre>

<p>If no action is given The Frood defaults to the <code>index</code> action.</p>

<h2>The <code>public</code> app</h2>

<p>This app is what anonymous users will access from their browsers.</p>

<p>It can be used by requesting the following URI's:</p>

<ul>
<li>/modules/[moduleName]/public/[controller]/[action]</li>
<li>/modules/[moduleName]/[controller]/[action]</li>
<li>/modules/[moduleName]</li>
</ul>

<p>The latter of these will default to the <code>index</code> controller and the <code>index</code> action.</p>

<h2>The other apps</h2>

<ul>
<li>The <code>admin</code> app can only be accessed with a valid XOOPS login.</li>
<li>The <code>local</code> app can only be accessed from our web servers. It is used to provide API's to interoperate between our modules.</li>
<li>The <code>cron</code> app is intended for cronjobs and can only be accessed from the shell.</li>
</ul>

<h1>Commandline Frood</h1>

<p>The Frood apps can all be invoked from the command line. This is useful for testing, but most significantly it allows you to use The Frood for cronjobs:</p>

<p><code>shell.php</code> is located in the <code>lib/frood/run/</code> folder. You invoke it like this:</p>

<pre><code>php shell.php [module] [app] [controller] [action] [parameter1]=[value1]...
</code></pre>

<h1>Extending the Frood controller</h1>

<p>It is not required to extend the <a href="Frood/Class/FroodController.html"><code>FroodController</code></a> to make use of Frood, but for various reasons it is usually a good idea:</p>

<ul>
<li>You may need to include the header file in legacy modules.</li>
<li>You may need to output something which is not directly supported by Frood.</li>
</ul>

<h2>Example</h2>

<p>In this example we overwrite the <a href="Frood/Class/FroodController.html#render"><code>FroodController::render()</code></a> method to add a new output method, <code>doOutputImage()</code> for outputting images. Additionally we need to create a method, <code>_renderImage()</code> and a constant <code>_IMAGE</code>.</p>

<p>We also add a method, <code>_includeHeader()</code> for including the header file for the module, to support some legacy dependencies.</p>

<p>To make sure all our actions include the header we overwrite <a href="Frood/Class/FroodController.html#__construct"><code>FroodController::__construct()</code></a> and call the <code>_requireHeader()</code> there. If only some of your actions need XOOPS, you can also just call <code>_requireHeader()</code> in the individual actions. The latter is the better solution, performance wise, as loading the whole header if you don't need it is unnecessary. The former is convenient if you know you need it for all your actions.</p>

<pre><code>    &lt;?php
    abstract class SomeController extends FroodController {

        /** @var string Output mode Image. */
        const _IMAGE = 'Image';

        /**
         * Construct a new controller instance.
         * This is automatically called from The Frood.
         *
         * @param string $module The module we're working with.
         * @param string $app    Which application are we running?
         *
         * @return void
         */
        public function __construct($module, $app) {
            parent::__construct($module, $app);
            $this-&gt;_requireHeader();
        }

        /**
         * Render the output.
         * The Frood calls this when appropriate.
         *
         * @param string $action The action to render the view for.
         *
         * @return void
         *
         * @throws RuntimeException For undefined output modes.
         */
        public function render($action) {
            switch ($this-&gt;_getOutputMode()) {
                case self::_IMAGE:
                    $this-&gt;_renderImage($action);
                    break;
                default:
                    parent::render($action);
                    break;
            }
        }

        /**
         * Include the module header file.
         *
         * @return void
         */
        protected function _requireHeader() {
            include_once dirname(__FILE__) . '/../../../header.php';
        }

        /**
         * Set the output mode to image.
         *
         * @return void
         */
        final public function doOutputImage() {
            $this-&gt;_doOutput(self::_IMAGE);
        }

        /**
         * Render the output as an image.
         *
         * @param string $action The action to render the view for.
         *
         * @return string The rendered output.
         */
        private function _renderImage($action) {
            $image = new XphotoImage($this-&gt;_getValue('imageId'));
            header('Content-Type: ' . $image-&gt;getMimeType());
            header('Content-Disposition: attachment; filename="'
                . $this-&gt;_getValue('imageId')
                . $image-&gt;getExtension() . '"');
            header('Content-Length: ' . filesize($image-&gt;getFile(true)));
            echo file_get_contents($image-&gt;getFile(true));
        }
    }
    ?&gt;
</code></pre>
